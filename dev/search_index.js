var documenterSearchIndex = {"docs":
[{"location":"abstract_types/#Type-hierarchy","page":"Abstract Types","title":"Type hierarchy","text":"","category":"section"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"The root of the type hierarchy tree in ReferenceFiniteElements is the following  abstract type.","category":"page"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"ReferenceFiniteElements.AbstractElementType","category":"page"},{"location":"abstract_types/#ReferenceFiniteElements.AbstractElementType","page":"Abstract Types","title":"ReferenceFiniteElements.AbstractElementType","text":"abstract type AbstractElementType{D, V, E, F, I, P, Q}\n\nBase type for the package that all element types are subtyped off of. The parameters have the following general meaning.\n\nD - Dimension\n\nV - Number of vertices\n\nE - Number of edges\n\nF - Number of faces``\n\nI - Interpolation type\n\nP - Polynomial degree\n\nQ - quadrature degree\n\n\n\n\n\n","category":"type"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"There are some useful methods associated with this abstrac type such ass","category":"page"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"ReferenceFiniteElements.dimension\nReferenceFiniteElements.interpolation_type\nReferenceFiniteElements.polynomial_degree\nReferenceFiniteElements.quadrature_degree","category":"page"},{"location":"abstract_types/#ReferenceFiniteElements.dimension","page":"Abstract Types","title":"ReferenceFiniteElements.dimension","text":"dimension(\n    _::ReferenceFiniteElements.AbstractElementType{D, V, E, F, I, P, Q}\n) -> Any\n\n\nReturns dimension D.\n\n\n\n\n\n","category":"function"},{"location":"abstract_types/#ReferenceFiniteElements.interpolation_type","page":"Abstract Types","title":"ReferenceFiniteElements.interpolation_type","text":"interpolation_type(\n    _::ReferenceFiniteElements.AbstractElementType{D, V, E, F, I, P, Q}\n) -> Any\n\n\nReturns the interpolation type I.\n\n\n\n\n\n","category":"function"},{"location":"abstract_types/#ReferenceFiniteElements.polynomial_degree","page":"Abstract Types","title":"ReferenceFiniteElements.polynomial_degree","text":"polynomial_degree(\n    _::ReferenceFiniteElements.AbstractElementType{D, V, E, F, I, P, Q}\n) -> Any\n\n\nReturns the interpolation polynomial degree P.\n\n\n\n\n\npolynomial_degree(\n    _::Type{<:ReferenceFiniteElements.AbstractElementType{D, V, E, F, I, P, Q}}\n) -> Any\n\n\nReturns the interpolation polynomial degree P.\n\n\n\n\n\n","category":"function"},{"location":"abstract_types/#ReferenceFiniteElements.quadrature_degree","page":"Abstract Types","title":"ReferenceFiniteElements.quadrature_degree","text":"quadrature_degree(\n    _::ReferenceFiniteElements.AbstractElementType{D, V, E, F, I, P, Q}\n) -> Any\n\n\nReturn the quadrature degree Q\n\n\n\n\n\n","category":"function"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"That can fetch the parameteric types.","category":"page"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"Other useful methods associated with this abstract type are the following which can be used to query information about the element topology.","category":"page"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"ReferenceFiniteElements.num_edges\nReferenceFiniteElements.num_faces\nReferenceFiniteElements.num_interior_vertices\nReferenceFiniteElements.num_quadrature_points\nReferenceFiniteElements.num_shape_functions\nReferenceFiniteElements.num_vertices\nReferenceFiniteElements.num_vertices_per_edge\nReferenceFiniteElements.num_vertices_per_face","category":"page"},{"location":"abstract_types/#ReferenceFiniteElements.num_edges","page":"Abstract Types","title":"ReferenceFiniteElements.num_edges","text":"num_edges(\n    _::ReferenceFiniteElements.AbstractElementType{D, V, E, F, I, P, Q}\n) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"abstract_types/#ReferenceFiniteElements.num_faces","page":"Abstract Types","title":"ReferenceFiniteElements.num_faces","text":"num_faces(\n    _::ReferenceFiniteElements.AbstractElementType{D, V, E, F, I, P, Q}\n) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"abstract_types/#ReferenceFiniteElements.num_interior_vertices","page":"Abstract Types","title":"ReferenceFiniteElements.num_interior_vertices","text":"\n\n\n\n","category":"function"},{"location":"abstract_types/#ReferenceFiniteElements.num_quadrature_points","page":"Abstract Types","title":"ReferenceFiniteElements.num_quadrature_points","text":"\n\n\n\n","category":"function"},{"location":"abstract_types/#ReferenceFiniteElements.num_shape_functions","page":"Abstract Types","title":"ReferenceFiniteElements.num_shape_functions","text":"num_shape_functions(\n    e::ReferenceFiniteElements.AbstractElementType{D, V, E, F, Lagrange, P, Q}\n) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"abstract_types/#ReferenceFiniteElements.num_vertices","page":"Abstract Types","title":"ReferenceFiniteElements.num_vertices","text":"num_vertices(\n    _::ReferenceFiniteElements.AbstractElementType{D, V, E, F, I, P, Q}\n) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"abstract_types/#ReferenceFiniteElements.num_vertices_per_edge","page":"Abstract Types","title":"ReferenceFiniteElements.num_vertices_per_edge","text":"\n\n\n\n","category":"function"},{"location":"abstract_types/#ReferenceFiniteElements.num_vertices_per_face","page":"Abstract Types","title":"ReferenceFiniteElements.num_vertices_per_face","text":"\n\n\n\n","category":"function"},{"location":"abstract_types/#0-Dimensional-Element-types","page":"Abstract Types","title":"0-Dimensional Element types","text":"","category":"section"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"Different types of 0-D elements (e.g. vertices of various implementations) can be implemented by subtyping off of the abstract type","category":"page"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"ReferenceFiniteElements.AbstractVertex","category":"page"},{"location":"abstract_types/#ReferenceFiniteElements.AbstractVertex","page":"Abstract Types","title":"ReferenceFiniteElements.AbstractVertex","text":"abstract type AbstractVertex{I, P, Q} <: ReferenceFiniteElements.AbstractElementType{0, 1, 0, 0, I, P, Q}\n\n\n\n\n\n","category":"type"},{"location":"abstract_types/#1-Dimensional-Element-types","page":"Abstract Types","title":"1-Dimensional Element types","text":"","category":"section"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"Different types of 1-D elements (e.g. edges, sides, lines, etc. of various implementations) can be implemented by subtyping off of the abstract type","category":"page"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"ReferenceFiniteElements.AbstractEdge","category":"page"},{"location":"abstract_types/#ReferenceFiniteElements.AbstractEdge","page":"Abstract Types","title":"ReferenceFiniteElements.AbstractEdge","text":"abstract type AbstractEdge{V, I, P, Q} <: ReferenceFiniteElements.AbstractElementType{1, V, 1, 0, I, P, Q}\n\n\n\n\n\n","category":"type"},{"location":"abstract_types/#2-Dimensional-Element-types","page":"Abstract Types","title":"2-Dimensional Element types","text":"","category":"section"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"Different types of 2-D elements (e.g. faces, triangles, quads, polygons, etc. of various implementations) can be implemented by subtyping off of the abstract type","category":"page"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"ReferenceFiniteElements.AbstractFace","category":"page"},{"location":"abstract_types/#ReferenceFiniteElements.AbstractFace","page":"Abstract Types","title":"ReferenceFiniteElements.AbstractFace","text":"abstract type AbstractFace{V, E, I, P, Q} <: ReferenceFiniteElements.AbstractElementType{2, V, E, 1, I, P, Q}\n\n\n\n\n\n","category":"type"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"There are also various subtypes of this type including","category":"page"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"ReferenceFiniteElements.AbstractQuad\nReferenceFiniteElements.AbstractTri","category":"page"},{"location":"abstract_types/#ReferenceFiniteElements.AbstractQuad","page":"Abstract Types","title":"ReferenceFiniteElements.AbstractQuad","text":"abstract type AbstractQuad{V, I, P, Q} <: ReferenceFiniteElements.AbstractFace{V, 4, I, P, Q}\n\n\n\n\n\n","category":"type"},{"location":"abstract_types/#ReferenceFiniteElements.AbstractTri","page":"Abstract Types","title":"ReferenceFiniteElements.AbstractTri","text":"abstract type AbstractTri{V, I, P, Q} <: ReferenceFiniteElements.AbstractFace{V, 3, I, P, Q}\n\n\n\n\n\n","category":"type"},{"location":"abstract_types/#3-Dimensional-Element-types","page":"Abstract Types","title":"3-Dimensional Element types","text":"","category":"section"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"Different types of 3-D elements (e.g. volumes, hexes, tets, etc. of various implementations) can be implemented by subtyping off of the abstract type","category":"page"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"ReferenceFiniteElements.AbstractVolume","category":"page"},{"location":"abstract_types/#ReferenceFiniteElements.AbstractVolume","page":"Abstract Types","title":"ReferenceFiniteElements.AbstractVolume","text":"abstract type AbstractVolume{V, E, F, I, P, Q} <: ReferenceFiniteElements.AbstractElementType{3, V, E, F, I, P, Q}\n\n\n\n\n\n","category":"type"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"There are also various subtypes of this type including","category":"page"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"ReferenceFiniteElements.AbstractHex\nReferenceFiniteElements.AbstractTet","category":"page"},{"location":"abstract_types/#ReferenceFiniteElements.AbstractHex","page":"Abstract Types","title":"ReferenceFiniteElements.AbstractHex","text":"abstract type AbstractHex{V, I, P, Q} <: ReferenceFiniteElements.AbstractVolume{V, 12, 6, I, P, Q}\n\n\n\n\n\n","category":"type"},{"location":"abstract_types/#ReferenceFiniteElements.AbstractTet","page":"Abstract Types","title":"ReferenceFiniteElements.AbstractTet","text":"abstract type AbstractTet{V, I, P, Q} <: ReferenceFiniteElements.AbstractVolume{V, 6, 4, I, P, Q}\n\n\n\n\n\n","category":"type"},{"location":"abstract_types/#Abstract-Types-for-Storage-Containers","page":"Abstract Types","title":"Abstract Types for Storage Containers","text":"","category":"section"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"ReferenceFiniteElements.AbstractInterpolationType\nReferenceFiniteElements.AbstractInterpolantsContainer","category":"page"},{"location":"abstract_types/#ReferenceFiniteElements.AbstractInterpolationType","page":"Abstract Types","title":"ReferenceFiniteElements.AbstractInterpolationType","text":"abstract type AbstractInterpolationType\n\n\n\n\n\n","category":"type"},{"location":"abstract_types/#ReferenceFiniteElements.AbstractInterpolantsContainer","page":"Abstract Types","title":"ReferenceFiniteElements.AbstractInterpolantsContainer","text":"abstract type AbstractInterpolantsContainer{I}\n\n\n\n\n\n","category":"type"},{"location":"storage_types/","page":"output","title":"output","text":"<!– ```@meta CurrentModule = ReferenceFiniteElements","category":"page"},{"location":"storage_types/","page":"output","title":"output","text":"\n# Storage types\nThere are different storage types available for the main type `ReferenceFE` beyond the default settings of `StructArrays` composed of `StaticArrays`. To use these default types we can use the following optional keyword arguments in the constructors as follows\n","category":"page"},{"location":"storage_types/","page":"output","title":"output","text":"jldoctest using ReferenceFiniteElements using StaticArrays","category":"page"},{"location":"storage_types/","page":"output","title":"output","text":"re = ReferenceFE(   Hex8(2);    inttype=Int64, floattype=Float64,    arraytype=MArray, storagetype=Array )","category":"page"},{"location":"storage_types/#output","page":"output","title":"output","text":"","category":"section"},{"location":"storage_types/","page":"output","title":"output","text":"ReferenceFE   Element type                = Hex8{8}   Dimension                   = 3   Number of nodes             = 8   Number of quadrature points = 8   Integer type                = Int64   Float type                  = Float64   Nodal coordinates type      = Matrix{Float64}   Edge nodes type             = Matrix{Int64}   Face nodes type             = Matrix{Int64}   Interior nodes type         = Vector{Int64}   Interpolants type           = Interpolants{MArray, MArray, MArray}","category":"page"},{"location":"storage_types/","page":"output","title":"output","text":"``The example above now uses mutableMArrays rather than the default ofSArray. The storage type is also now aVectorofMArrays rather than aStructArrayofMArrays. The currently supported internal array types areArray,MArray, andSArray. The currently supported storage types areArrayandStructArray`. –>","category":"page"},{"location":"quick_start/","page":"output","title":"output","text":"<!– ```@meta CurrentModule = ReferenceFiniteElements","category":"page"},{"location":"quick_start/","page":"output","title":"output","text":"\n# Quckstart\nTo setup a finite element you can do the following with a 8 node hexahedral element with a second order quadrature rule (8 integration points) used as an example below\n","category":"page"},{"location":"quick_start/","page":"output","title":"output","text":"jldoctest quickstart using ReferenceFiniteElements re = ReferenceFE(Hex8(2))","category":"page"},{"location":"quick_start/#output","page":"output","title":"output","text":"","category":"section"},{"location":"quick_start/","page":"output","title":"output","text":"ReferenceFE   Element type                = Hex8{8}   Dimension                   = 3   Number of nodes             = 8   Number of quadrature points = 8   Integer type                = Int64   Float type                  = Float64   Nodal coordinates type      = Matrix{Float64}   Edge nodes type             = Matrix{Int64}   Face nodes type             = Matrix{Int64}   Interior nodes type         = Vector{Int64}   Interpolants type           = StructArray{Interpolants}","category":"page"},{"location":"quick_start/","page":"output","title":"output","text":"\nTo do something useful with our finite element we can look at the quadrature points. To get all the quadrature points, use the following method\n","category":"page"},{"location":"quick_start/","page":"output","title":"output","text":"jldoctest quickstart ξs = quadrature_points(re)","category":"page"},{"location":"quick_start/#output-2","page":"output","title":"output","text":"","category":"section"},{"location":"quick_start/","page":"output","title":"output","text":"8-element Vector{StaticArraysCore.SVector{3, Float64}}:  [-0.5773502691896258, -0.5773502691896258, -0.5773502691896258]  [0.5773502691896258, -0.5773502691896258, -0.5773502691896258]  [-0.5773502691896258, 0.5773502691896258, -0.5773502691896258]  [0.5773502691896258, 0.5773502691896258, -0.5773502691896258]  [-0.5773502691896258, -0.5773502691896258, 0.5773502691896258]  [0.5773502691896258, -0.5773502691896258, 0.5773502691896258]  [-0.5773502691896258, 0.5773502691896258, 0.5773502691896258]  [0.5773502691896258, 0.5773502691896258, 0.5773502691896258]","category":"page"},{"location":"quick_start/","page":"output","title":"output","text":"\nTo get a specific quadrature point, say the first point, we can use an analogous method as follows\n","category":"page"},{"location":"quick_start/","page":"output","title":"output","text":"jldoctest quickstart ξ = quadrature_points(re, 1)","category":"page"},{"location":"quick_start/#output-3","page":"output","title":"output","text":"","category":"section"},{"location":"quick_start/","page":"output","title":"output","text":"3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):  -0.5773502691896258  -0.5773502691896258  -0.5773502691896258","category":"page"},{"location":"quick_start/","page":"output","title":"output","text":"\nThere are similar methods for the quadrature weights. See below.\n","category":"page"},{"location":"quick_start/","page":"output","title":"output","text":"jldoctest quickstart ws = quadrature_weights(re)","category":"page"},{"location":"quick_start/#output-4","page":"output","title":"output","text":"","category":"section"},{"location":"quick_start/","page":"output","title":"output","text":"8-element Vector{Float64}:  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0","category":"page"},{"location":"quick_start/","page":"output","title":"output","text":"","category":"page"},{"location":"quick_start/","page":"output","title":"output","text":"jldoctest quickstart w = quadrature_weights(re, 1)","category":"page"},{"location":"quick_start/#output-5","page":"output","title":"output","text":"","category":"section"},{"location":"quick_start/","page":"output","title":"output","text":"1.0","category":"page"},{"location":"quick_start/","page":"output","title":"output","text":"\nFor the shape function values we can access these via the following methods\n","category":"page"},{"location":"quick_start/","page":"output","title":"output","text":"jldoctest quickstart Ns = shapefunctionvalues(re)","category":"page"},{"location":"quick_start/#output-6","page":"output","title":"output","text":"","category":"section"},{"location":"quick_start/","page":"output","title":"output","text":"8-element Vector{StaticArraysCore.SVector{8, Float64}}:  [0.4905626121623441, 0.13144585576580212, 0.035220810900864506, 0.13144585576580212, 0.13144585576580212, 0.035220810900864506, 0.009437387837655926, 0.035220810900864506]  [0.13144585576580212, 0.4905626121623441, 0.13144585576580212, 0.035220810900864506, 0.035220810900864506, 0.13144585576580212, 0.035220810900864506, 0.009437387837655926]  [0.13144585576580212, 0.035220810900864506, 0.13144585576580212, 0.4905626121623441, 0.035220810900864506, 0.009437387837655926, 0.035220810900864506, 0.13144585576580212]  [0.035220810900864506, 0.13144585576580212, 0.4905626121623441, 0.13144585576580212, 0.009437387837655926, 0.035220810900864506, 0.13144585576580212, 0.035220810900864506]  [0.13144585576580212, 0.035220810900864506, 0.009437387837655926, 0.035220810900864506, 0.4905626121623441, 0.13144585576580212, 0.035220810900864506, 0.13144585576580212]  [0.035220810900864506, 0.13144585576580212, 0.035220810900864506, 0.009437387837655926, 0.13144585576580212, 0.4905626121623441, 0.13144585576580212, 0.035220810900864506]  [0.035220810900864506, 0.009437387837655926, 0.035220810900864506, 0.13144585576580212, 0.13144585576580212, 0.035220810900864506, 0.13144585576580212, 0.4905626121623441]  [0.009437387837655926, 0.035220810900864506, 0.13144585576580212, 0.035220810900864506, 0.035220810900864506, 0.13144585576580212, 0.4905626121623441, 0.13144585576580212]","category":"page"},{"location":"quick_start/","page":"output","title":"output","text":"","category":"page"},{"location":"quick_start/","page":"output","title":"output","text":"jldoctest quickstart N = shapefunctionvalues(re, 1)","category":"page"},{"location":"quick_start/#output-7","page":"output","title":"output","text":"","category":"section"},{"location":"quick_start/","page":"output","title":"output","text":"8-element StaticArraysCore.SVector{8, Float64} with indices SOneTo(8):  0.4905626121623441  0.13144585576580212  0.035220810900864506  0.13144585576580212  0.13144585576580212  0.035220810900864506  0.009437387837655926  0.035220810900864506","category":"page"},{"location":"quick_start/","page":"output","title":"output","text":"\nFor shape function gradients, the method calls are as follows","category":"page"},{"location":"quick_start/","page":"output","title":"output","text":"jldoctest quickstart ∇Nξ = shapefunction_gradients(re)","category":"page"},{"location":"quick_start/#output-8","page":"output","title":"output","text":"","category":"section"},{"location":"quick_start/","page":"output","title":"output","text":"8-element Vector{StaticArraysCore.SMatrix{8, 3, Float64, 24}}:  [-0.3110042339640731 -0.3110042339640731 -0.3110042339640731; 0.3110042339640731 -0.08333333333333331 -0.08333333333333331; … ; 0.022329099369260218 0.022329099369260218 0.022329099369260218; -0.022329099369260218 0.08333333333333331 0.08333333333333331]  [-0.3110042339640731 -0.08333333333333331 -0.08333333333333331; 0.3110042339640731 -0.3110042339640731 -0.3110042339640731; … ; 0.022329099369260218 0.08333333333333331 0.08333333333333331; -0.022329099369260218 0.022329099369260218 0.022329099369260218]  [-0.08333333333333331 -0.3110042339640731 -0.08333333333333331; 0.08333333333333331 -0.08333333333333331 -0.022329099369260218; … ; 0.08333333333333331 0.022329099369260218 0.08333333333333331; -0.08333333333333331 0.08333333333333331 0.3110042339640731]  [-0.08333333333333331 -0.08333333333333331 -0.022329099369260218; 0.08333333333333331 -0.3110042339640731 -0.08333333333333331; … ; 0.08333333333333331 0.08333333333333331 0.3110042339640731; -0.08333333333333331 0.022329099369260218 0.08333333333333331]  [-0.08333333333333331 -0.08333333333333331 -0.3110042339640731; 0.08333333333333331 -0.022329099369260218 -0.08333333333333331; … ; 0.08333333333333331 0.08333333333333331 0.022329099369260218; -0.08333333333333331 0.3110042339640731 0.08333333333333331]  [-0.08333333333333331 -0.022329099369260218 -0.08333333333333331; 0.08333333333333331 -0.08333333333333331 -0.3110042339640731; … ; 0.08333333333333331 0.3110042339640731 0.08333333333333331; -0.08333333333333331 0.08333333333333331 0.022329099369260218]  [-0.022329099369260218 -0.08333333333333331 -0.08333333333333331; 0.022329099369260218 -0.022329099369260218 -0.022329099369260218; … ; 0.3110042339640731 0.08333333333333331 0.08333333333333331; -0.3110042339640731 0.3110042339640731 0.3110042339640731]  [-0.022329099369260218 -0.022329099369260218 -0.022329099369260218; 0.022329099369260218 -0.08333333333333331 -0.08333333333333331; … ; 0.3110042339640731 0.3110042339640731 0.3110042339640731; -0.3110042339640731 0.08333333333333331 0.08333333333333331]","category":"page"},{"location":"quick_start/","page":"output","title":"output","text":"","category":"page"},{"location":"quick_start/","page":"output","title":"output","text":"jldoctest quickstart ∇Nξ = shapefunction_gradients(re, 1)","category":"page"},{"location":"quick_start/#output-9","page":"output","title":"output","text":"","category":"section"},{"location":"quick_start/","page":"output","title":"output","text":"8×3 StaticArraysCore.SMatrix{8, 3, Float64, 24} with indices SOneTo(8)×SOneTo(3):  -0.311004   -0.311004   -0.311004   0.311004   -0.0833333  -0.0833333   0.0833333   0.0833333  -0.0223291  -0.0833333   0.311004   -0.0833333  -0.0833333  -0.0833333   0.311004   0.0833333  -0.0223291   0.0833333   0.0223291   0.0223291   0.0223291  -0.0223291   0.0833333   0.0833333","category":"page"},{"location":"quick_start/","page":"output","title":"output","text":"\nFor shape function hessians, the method calls are as follows\n","category":"page"},{"location":"quick_start/","page":"output","title":"output","text":"jldoctest quickstart ∇∇Nξ = shapefunction_hessians(re)","category":"page"},{"location":"quick_start/#output-10","page":"output","title":"output","text":"","category":"section"},{"location":"quick_start/","page":"output","title":"output","text":"8-element Vector{StaticArraysCore.SArray{Tuple{8, 3, 3}, Float64, 3, 72}}:  [0.0 0.19716878364870322 0.19716878364870322; 0.0 -0.19716878364870322 -0.19716878364870322; … ; 0.0 0.05283121635129677 0.05283121635129677; 0.0 -0.05283121635129677 -0.05283121635129677;;; 0.19716878364870322 0.0 0.19716878364870322; -0.19716878364870322 0.0 0.05283121635129677; … ; 0.05283121635129677 0.0 0.05283121635129677; -0.05283121635129677 0.0 0.19716878364870322;;; 0.19716878364870322 0.19716878364870322 0.0; -0.19716878364870322 0.05283121635129677 0.0; … ; 0.05283121635129677 0.05283121635129677 0.0; -0.05283121635129677 0.19716878364870322 0.0]  [0.0 0.19716878364870322 0.19716878364870322; 0.0 -0.19716878364870322 -0.19716878364870322; … ; 0.0 0.05283121635129677 0.05283121635129677; 0.0 -0.05283121635129677 -0.05283121635129677;;; 0.19716878364870322 0.0 0.05283121635129677; -0.19716878364870322 0.0 0.19716878364870322; … ; 0.05283121635129677 0.0 0.19716878364870322; -0.05283121635129677 0.0 0.05283121635129677;;; 0.19716878364870322 0.05283121635129677 0.0; -0.19716878364870322 0.19716878364870322 0.0; … ; 0.05283121635129677 0.19716878364870322 0.0; -0.05283121635129677 0.05283121635129677 0.0]  [0.0 0.19716878364870322 0.05283121635129677; 0.0 -0.19716878364870322 -0.05283121635129677; … ; 0.0 0.05283121635129677 0.19716878364870322; 0.0 -0.05283121635129677 -0.19716878364870322;;; 0.19716878364870322 0.0 0.19716878364870322; -0.19716878364870322 0.0 0.05283121635129677; … ; 0.05283121635129677 0.0 0.05283121635129677; -0.05283121635129677 0.0 0.19716878364870322;;; 0.05283121635129677 0.19716878364870322 0.0; -0.05283121635129677 0.05283121635129677 0.0; … ; 0.19716878364870322 0.05283121635129677 0.0; -0.19716878364870322 0.19716878364870322 0.0]  [0.0 0.19716878364870322 0.05283121635129677; 0.0 -0.19716878364870322 -0.05283121635129677; … ; 0.0 0.05283121635129677 0.19716878364870322; 0.0 -0.05283121635129677 -0.19716878364870322;;; 0.19716878364870322 0.0 0.05283121635129677; -0.19716878364870322 0.0 0.19716878364870322; … ; 0.05283121635129677 0.0 0.19716878364870322; -0.05283121635129677 0.0 0.05283121635129677;;; 0.05283121635129677 0.05283121635129677 0.0; -0.05283121635129677 0.19716878364870322 0.0; … ; 0.19716878364870322 0.19716878364870322 0.0; -0.19716878364870322 0.05283121635129677 0.0]  [0.0 0.05283121635129677 0.19716878364870322; 0.0 -0.05283121635129677 -0.19716878364870322; … ; 0.0 0.19716878364870322 0.05283121635129677; 0.0 -0.19716878364870322 -0.05283121635129677;;; 0.05283121635129677 0.0 0.19716878364870322; -0.05283121635129677 0.0 0.05283121635129677; … ; 0.19716878364870322 0.0 0.05283121635129677; -0.19716878364870322 0.0 0.19716878364870322;;; 0.19716878364870322 0.19716878364870322 0.0; -0.19716878364870322 0.05283121635129677 0.0; … ; 0.05283121635129677 0.05283121635129677 0.0; -0.05283121635129677 0.19716878364870322 0.0]  [0.0 0.05283121635129677 0.19716878364870322; 0.0 -0.05283121635129677 -0.19716878364870322; … ; 0.0 0.19716878364870322 0.05283121635129677; 0.0 -0.19716878364870322 -0.05283121635129677;;; 0.05283121635129677 0.0 0.05283121635129677; -0.05283121635129677 0.0 0.19716878364870322; … ; 0.19716878364870322 0.0 0.19716878364870322; -0.19716878364870322 0.0 0.05283121635129677;;; 0.19716878364870322 0.05283121635129677 0.0; -0.19716878364870322 0.19716878364870322 0.0; … ; 0.05283121635129677 0.19716878364870322 0.0; -0.05283121635129677 0.05283121635129677 0.0]  [0.0 0.05283121635129677 0.05283121635129677; 0.0 -0.05283121635129677 -0.05283121635129677; … ; 0.0 0.19716878364870322 0.19716878364870322; 0.0 -0.19716878364870322 -0.19716878364870322;;; 0.05283121635129677 0.0 0.19716878364870322; -0.05283121635129677 0.0 0.05283121635129677; … ; 0.19716878364870322 0.0 0.05283121635129677; -0.19716878364870322 0.0 0.19716878364870322;;; 0.05283121635129677 0.19716878364870322 0.0; -0.05283121635129677 0.05283121635129677 0.0; … ; 0.19716878364870322 0.05283121635129677 0.0; -0.19716878364870322 0.19716878364870322 0.0]  [0.0 0.05283121635129677 0.05283121635129677; 0.0 -0.05283121635129677 -0.05283121635129677; … ; 0.0 0.19716878364870322 0.19716878364870322; 0.0 -0.19716878364870322 -0.19716878364870322;;; 0.05283121635129677 0.0 0.05283121635129677; -0.05283121635129677 0.0 0.19716878364870322; … ; 0.19716878364870322 0.0 0.19716878364870322; -0.19716878364870322 0.0 0.05283121635129677;;; 0.05283121635129677 0.05283121635129677 0.0; -0.05283121635129677 0.19716878364870322 0.0; … ; 0.19716878364870322 0.19716878364870322 0.0; -0.19716878364870322 0.05283121635129677 0.0]","category":"page"},{"location":"quick_start/","page":"output","title":"output","text":"","category":"page"},{"location":"quick_start/","page":"output","title":"output","text":"jldoctest quickstart ∇∇Nξ = shapefunction_hessians(re, 1)","category":"page"},{"location":"quick_start/#output-11","page":"output","title":"output","text":"","category":"section"},{"location":"quick_start/","page":"output","title":"output","text":"8×3×3 StaticArraysCore.SArray{Tuple{8, 3, 3}, Float64, 3, 72} with indices SOneTo(8)×SOneTo(3)×SOneTo(3): [:, :, 1] =  0.0   0.197169    0.197169  0.0  -0.197169   -0.197169  0.0   0.197169   -0.0528312  0.0  -0.197169    0.0528312  0.0   0.0528312  -0.197169  0.0  -0.0528312   0.197169  0.0   0.0528312   0.0528312  0.0  -0.0528312  -0.0528312","category":"page"},{"location":"quick_start/","page":"output","title":"output","text":"[:, :, 2] =   0.197169   0.0   0.197169  -0.197169   0.0   0.0528312   0.197169   0.0  -0.0528312  -0.197169   0.0  -0.197169   0.0528312  0.0  -0.197169  -0.0528312  0.0  -0.0528312   0.0528312  0.0   0.0528312  -0.0528312  0.0   0.197169","category":"page"},{"location":"quick_start/","page":"output","title":"output","text":"[:, :, 3] =   0.197169    0.197169   0.0  -0.197169    0.0528312  0.0  -0.0528312  -0.0528312  0.0   0.0528312  -0.197169   0.0  -0.197169   -0.197169   0.0   0.197169   -0.0528312  0.0   0.0528312   0.0528312  0.0  -0.0528312   0.197169   0.0","category":"page"},{"location":"quick_start/","page":"output","title":"output","text":"``` –>","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"CurrentModule = ReferenceFiniteElements","category":"page"},{"location":"developer/#How-to-add-a-new-element-type","page":"Developer","title":"How to add a new element type","text":"","category":"section"},{"location":"developer/","page":"Developer","title":"Developer","text":"To add a new finite element there's a few things we need to do. First, we may need to define an abstract type if the element type is not a currently supported abstract element topology. The currently supported abstract element topologies are   ","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"AbstractEdge\nAbstractHex\nAbstractQuad\nAbstractTet\nAbstractTri","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"We'll use a Tri3 element as an example of how to add a new element type.","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"First, let's pretend AbstractTri doesn't exist yet. The first thing we need to do is define the following abstract type","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"julia> using ReferenceFiniteElements\n\njulia> abstract type AbstractTri{V, I, P, Q} <: ReferenceFiniteElements.AbstractFace{V, 3, I, P, Q} end\n","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"The four parameters V, I, P, and Q are the number of vertices, interpolation type, the polynomial degree, and the number of quadrature degree for an element implementation. The dimension is fixed at 2 for the D parameter in the abstrac type. For a given element topology, such as a three noded triangle in this example, P will be fixed parameters while we allow for I and Q to be variable, i.e. have potentially different interpolation and quadrature rules on a 3 noded element. ","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"We now need to define some methods for basiscs about the element toplogy such as number of vertices, edges, faces, etc.","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"e.g. ","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"julia> num_edges(e::Type{<:AbstractTri}) = 3\nnum_edges (generic function with 1 method)\n\n","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"The complete list of methods that need to be defined for a new abstract topology type include the following:","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"element_edge_nodes\nelement_face_nodes\nelement_interior_nodes\nnodal_coordinates\nnum_edges\nnum_faces\nnum_interior_vertices\nnum_quadrature_points\nnum_vertices\nnum_vertices_per_edge\nnum_vertices_per_face\nquadrature_points_and_weights\nsurface_element\nsurface_element_type\nsurface_nodal_coordinates\nsurface_quadrature_points_and_weights","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"Now we define a struct for specific implementations. Here we'll define the Tri3 struct.","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"julia> struct Tri3{I, Q} <: AbstractTri{3, I, 1, Q} end\n\njulia> e = Tri3{Lagrange, 1}()\nTri3{Lagrange, 1}()\n\njulia> num_edges(typeof(e))\n3","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"Here we have fixed P to be 1 respectively while I and Q are left as parametric types.","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"We can also define some type stable constructors for different quadrature degrees. This look like the following","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"Now that we have a basic type to represent our element topology defined, there's a few methods we need to define for setup purposes. These methods can be split into methods need for abstract element topology types, such as AbstractTri, and methods needed for specific element types such as Tri3.","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"The methods needed for specific interpolation types include the following:","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"shape_function_values\nshape_funciton_gradients\nshape_function_hessians","category":"page"},{"location":"element_types/#0-Dimensional-Elements","page":"Element Types","title":"0-Dimensional Elements","text":"","category":"section"},{"location":"element_types/","page":"Element Types","title":"Element Types","text":"Vertex","category":"page"},{"location":"element_types/#ReferenceFiniteElements.Vertex","page":"Element Types","title":"ReferenceFiniteElements.Vertex","text":"struct Vertex{I, P, Q} <: ReferenceFiniteElements.AbstractVertex{I, P, Q}\n\n\n\n\n\n","category":"type"},{"location":"element_types/#1-Dimensional-Elements","page":"Element Types","title":"1-Dimensional Elements","text":"","category":"section"},{"location":"element_types/","page":"Element Types","title":"Element Types","text":"Edge\nEdge0\nEdge2\nEdge3","category":"page"},{"location":"element_types/#ReferenceFiniteElements.Edge","page":"Element Types","title":"ReferenceFiniteElements.Edge","text":"struct Edge{V, I, P, Q} <: ReferenceFiniteElements.AbstractEdge{V, I, P, Q}\n\n\n\n\n\n","category":"type"},{"location":"element_types/#ReferenceFiniteElements.Edge0","page":"Element Types","title":"ReferenceFiniteElements.Edge0","text":"struct Edge0{I, Q} <: ReferenceFiniteElements.AbstractEdge{2, I, 0, Q}\n\n\n\n\n\n","category":"type"},{"location":"element_types/#ReferenceFiniteElements.Edge2","page":"Element Types","title":"ReferenceFiniteElements.Edge2","text":"struct Edge2{I, Q} <: ReferenceFiniteElements.AbstractEdge{2, I, 1, Q}\n\n\n\n\n\n","category":"type"},{"location":"element_types/#ReferenceFiniteElements.Edge3","page":"Element Types","title":"ReferenceFiniteElements.Edge3","text":"struct Edge3{I, Q} <: ReferenceFiniteElements.AbstractEdge{3, I, 2, Q}\n\n\n\n\n\n","category":"type"},{"location":"element_types/#2-Dimensional-Elements","page":"Element Types","title":"2-Dimensional Elements","text":"","category":"section"},{"location":"element_types/","page":"Element Types","title":"Element Types","text":"Quad\nQuad0\nQuad4\nQuad9\nTri\nTri0\nTri3\nTri6","category":"page"},{"location":"element_types/#ReferenceFiniteElements.Quad","page":"Element Types","title":"ReferenceFiniteElements.Quad","text":"struct Quad{V, I, P, Q} <: ReferenceFiniteElements.AbstractQuad{V, I, P, Q}\n\n\n\n\n\n","category":"type"},{"location":"element_types/#ReferenceFiniteElements.Quad0","page":"Element Types","title":"ReferenceFiniteElements.Quad0","text":"struct Quad0{I, Q} <: ReferenceFiniteElements.AbstractQuad{4, I, 0, Q}\n\n\n\n\n\n","category":"type"},{"location":"element_types/#ReferenceFiniteElements.Quad4","page":"Element Types","title":"ReferenceFiniteElements.Quad4","text":"struct Quad4{I, Q} <: ReferenceFiniteElements.AbstractQuad{4, I, 1, Q}\n\n\n\n\n\n","category":"type"},{"location":"element_types/#ReferenceFiniteElements.Quad9","page":"Element Types","title":"ReferenceFiniteElements.Quad9","text":"struct Quad9{I, Q} <: ReferenceFiniteElements.AbstractQuad{9, I, 2, Q}\n\n\n\n\n\n","category":"type"},{"location":"element_types/#ReferenceFiniteElements.Tri","page":"Element Types","title":"ReferenceFiniteElements.Tri","text":"struct Tri{V, I, P, Q} <: ReferenceFiniteElements.AbstractTri{V, I, P, Q}\n\n\n\n\n\n","category":"type"},{"location":"element_types/#ReferenceFiniteElements.Tri0","page":"Element Types","title":"ReferenceFiniteElements.Tri0","text":"struct Tri0{I, Q} <: ReferenceFiniteElements.AbstractTri{3, I, 0, Q}\n\n\n\n\n\n","category":"type"},{"location":"element_types/#ReferenceFiniteElements.Tri3","page":"Element Types","title":"ReferenceFiniteElements.Tri3","text":"struct Tri3{I, Q} <: ReferenceFiniteElements.AbstractTri{3, I, 1, Q}\n\n\n\n\n\n","category":"type"},{"location":"element_types/#ReferenceFiniteElements.Tri6","page":"Element Types","title":"ReferenceFiniteElements.Tri6","text":"struct Tri6{I, Q} <: ReferenceFiniteElements.AbstractTri{6, I, 2, Q}\n\n\n\n\n\n","category":"type"},{"location":"element_types/#3-Dimensional-Elements","page":"Element Types","title":"3-Dimensional Elements","text":"","category":"section"},{"location":"element_types/","page":"Element Types","title":"Element Types","text":"Hex0\nHex8\nTet0\nTet4\nTet10","category":"page"},{"location":"element_types/#ReferenceFiniteElements.Hex0","page":"Element Types","title":"ReferenceFiniteElements.Hex0","text":"struct Hex0{I, Q} <: ReferenceFiniteElements.AbstractHex{8, I, 0, Q}\n\n\n\n\n\n","category":"type"},{"location":"element_types/#ReferenceFiniteElements.Hex8","page":"Element Types","title":"ReferenceFiniteElements.Hex8","text":"struct Hex8{I, Q} <: ReferenceFiniteElements.AbstractHex{8, I, 1, Q}\n\n\n\n\n\n","category":"type"},{"location":"element_types/#ReferenceFiniteElements.Tet0","page":"Element Types","title":"ReferenceFiniteElements.Tet0","text":"struct Tet0{I, Q} <: ReferenceFiniteElements.AbstractTet{4, I, 0, Q}\n\n\n\n\n\n","category":"type"},{"location":"element_types/#ReferenceFiniteElements.Tet4","page":"Element Types","title":"ReferenceFiniteElements.Tet4","text":"struct Tet4{I, Q} <: ReferenceFiniteElements.AbstractTet{4, I, 1, Q}\n\n\n\n\n\n","category":"type"},{"location":"element_types/#ReferenceFiniteElements.Tet10","page":"Element Types","title":"ReferenceFiniteElements.Tet10","text":"struct Tet10{I, Q} <: ReferenceFiniteElements.AbstractTet{10, I, 2, Q}\n\n\n\n\n\n","category":"type"},{"location":"installation/","page":"Installation","title":"Installation","text":"CurrentModule = ReferenceFiniteElements","category":"page"},{"location":"installation/#ReferenceFiniteElements","page":"Installation","title":"ReferenceFiniteElements","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Documentation for ReferenceFiniteElements.","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To use ReferenceFiniteElements first install it via the package manager via the following command","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"pkg> add ReferenceFiniteElements","category":"page"},{"location":"","page":"Index","title":"Index","text":"CurrentModule = ReferenceFiniteElements","category":"page"},{"location":"","page":"Index","title":"Index","text":"","category":"page"},{"location":"","page":"Index","title":"Index","text":"<!– @autodocs Modules = [ReferenceFiniteElements] –>","category":"page"},{"location":"extensions/#ReferenceFiniteElementsAdaptExt","page":"ReferenceFiniteElementsAdaptExt","title":"ReferenceFiniteElementsAdaptExt","text":"","category":"section"},{"location":"extensions/","page":"ReferenceFiniteElementsAdaptExt","title":"ReferenceFiniteElementsAdaptExt","text":"For using ReferenceFiniteElements on GPUs. So far only tested with CUDA.jl as the GPU backend.","category":"page"},{"location":"extensions/#ReferenceFiniteElementsExodusExt","page":"ReferenceFiniteElementsAdaptExt","title":"ReferenceFiniteElementsExodusExt","text":"","category":"section"},{"location":"extensions/","page":"ReferenceFiniteElementsAdaptExt","title":"ReferenceFiniteElementsAdaptExt","text":"Convenience methods for setting up ReferenceFEs based on an Exodus block. Really only useful if you use exodusII mesh types.","category":"page"},{"location":"extensions/#ReferenceFiniteElementsRecipesBaseExt","page":"ReferenceFiniteElementsAdaptExt","title":"ReferenceFiniteElementsRecipesBaseExt","text":"","category":"section"},{"location":"extensions/","page":"ReferenceFiniteElementsAdaptExt","title":"ReferenceFiniteElementsAdaptExt","text":"Plotting tools for educational purposes. To use, try the following","category":"page"},{"location":"extensions/","page":"ReferenceFiniteElementsAdaptExt","title":"ReferenceFiniteElementsAdaptExt","text":"using ReferenceFiniteElements, Plots, LaTeXStrings\nre = ReferenceFE(Tri6(2))\nplot(re) # plots nodes and edges of element along with quadrature points\nplot(re, 1) # plots shape function values. The index is the shape function index\nplot(re, 1, 1) # plots shape function gradients. The first index is for the index, second is for dimension\nplot(re, 1, 1, 1) # plots shape function hessians. The first index  is for the shape function index and the second and third are for dimensions","category":"page"}]
}
