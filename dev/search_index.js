var documenterSearchIndex = {"docs":
[{"location":"abstract_types/#Type-hierarchy","page":"Abstract Types","title":"Type hierarchy","text":"","category":"section"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"The root of the type hierarchy tree in ReferenceFiniteElements is the following  abstract type.","category":"page"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"ReferenceFiniteElements.AbstractElementType","category":"page"},{"location":"abstract_types/#ReferenceFiniteElements.AbstractElementType","page":"Abstract Types","title":"ReferenceFiniteElements.AbstractElementType","text":"abstract type AbstractElementType{D, V, E, F, I, P, Q}\n\nBase type for the package that all element types are subtyped off of. The parameters have the following general meaning.\n\nD - Dimension\n\nV - Number of vertices\n\nE - Number of edges\n\nF - Number of faces\n\nI - Interpolation type\n\nP - Polynomial degree\n\nQ - quadrature degree\n\n\n\n\n\n","category":"type"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"There are some useful methods associated with this abstract type such as","category":"page"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"ReferenceFiniteElements.dimension\nReferenceFiniteElements.num_vertices\nReferenceFiniteElements.num_edges\nReferenceFiniteElements.num_faces\nReferenceFiniteElements.interpolation_type\nReferenceFiniteElements.polynomial_degree\nReferenceFiniteElements.quadrature_degree","category":"page"},{"location":"abstract_types/#ReferenceFiniteElements.dimension","page":"Abstract Types","title":"ReferenceFiniteElements.dimension","text":"dimension(\n    _::ReferenceFiniteElements.AbstractElementType{D, V, E, F, I, P, Q}\n) -> Any\n\n\nReturns dimension D.\n\n\n\n\n\n","category":"function"},{"location":"abstract_types/#ReferenceFiniteElements.num_vertices","page":"Abstract Types","title":"ReferenceFiniteElements.num_vertices","text":"num_vertices(\n    _::ReferenceFiniteElements.AbstractElementType{D, V, E, F, I, P, Q}\n) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"abstract_types/#ReferenceFiniteElements.num_edges","page":"Abstract Types","title":"ReferenceFiniteElements.num_edges","text":"num_edges(\n    _::ReferenceFiniteElements.AbstractElementType{D, V, E, F, I, P, Q}\n) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"abstract_types/#ReferenceFiniteElements.num_faces","page":"Abstract Types","title":"ReferenceFiniteElements.num_faces","text":"num_faces(\n    _::ReferenceFiniteElements.AbstractElementType{D, V, E, F, I, P, Q}\n) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"abstract_types/#ReferenceFiniteElements.interpolation_type","page":"Abstract Types","title":"ReferenceFiniteElements.interpolation_type","text":"interpolation_type(\n    _::ReferenceFiniteElements.AbstractElementType{D, V, E, F, I, P, Q}\n) -> Any\n\n\nReturns the interpolation type I.\n\n\n\n\n\n","category":"function"},{"location":"abstract_types/#ReferenceFiniteElements.polynomial_degree","page":"Abstract Types","title":"ReferenceFiniteElements.polynomial_degree","text":"polynomial_degree(\n    _::ReferenceFiniteElements.AbstractElementType{D, V, E, F, I, P, Q}\n) -> Any\n\n\nReturns the interpolation polynomial degree P.\n\n\n\n\n\npolynomial_degree(\n    _::Type{<:ReferenceFiniteElements.AbstractElementType{D, V, E, F, I, P, Q}}\n) -> Any\n\n\nReturns the interpolation polynomial degree P.\n\n\n\n\n\n","category":"function"},{"location":"abstract_types/#ReferenceFiniteElements.quadrature_degree","page":"Abstract Types","title":"ReferenceFiniteElements.quadrature_degree","text":"quadrature_degree(\n    _::ReferenceFiniteElements.AbstractElementType{D, V, E, F, I, P, Q}\n) -> Any\n\n\nReturn the quadrature degree Q\n\n\n\n\n\n","category":"function"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"That can fetch the parameteric types.","category":"page"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"Other useful methods associated with this abstract type are the following which can be used to query information about the element topology.","category":"page"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"ReferenceFiniteElements.num_interior_vertices\nReferenceFiniteElements.num_quadrature_points\nReferenceFiniteElements.num_shape_functions\nReferenceFiniteElements.num_vertices_per_edge\nReferenceFiniteElements.num_vertices_per_face","category":"page"},{"location":"abstract_types/#ReferenceFiniteElements.num_interior_vertices","page":"Abstract Types","title":"ReferenceFiniteElements.num_interior_vertices","text":"\n\n\n\n","category":"function"},{"location":"abstract_types/#ReferenceFiniteElements.num_quadrature_points","page":"Abstract Types","title":"ReferenceFiniteElements.num_quadrature_points","text":"\n\n\n\n","category":"function"},{"location":"abstract_types/#ReferenceFiniteElements.num_shape_functions","page":"Abstract Types","title":"ReferenceFiniteElements.num_shape_functions","text":"num_shape_functions(\n    e::ReferenceFiniteElements.AbstractElementType{D, V, E, F, Lagrange, P, Q}\n) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"abstract_types/#ReferenceFiniteElements.num_vertices_per_edge","page":"Abstract Types","title":"ReferenceFiniteElements.num_vertices_per_edge","text":"\n\n\n\n","category":"function"},{"location":"abstract_types/#ReferenceFiniteElements.num_vertices_per_face","page":"Abstract Types","title":"ReferenceFiniteElements.num_vertices_per_face","text":"\n\n\n\n","category":"function"},{"location":"abstract_types/#Element-subtypes","page":"Abstract Types","title":"Element subtypes","text":"","category":"section"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"Below are additional abstract types subtyped off of AbstractElementType for element topologies of different dimensions and further subtyped based on common element topologies.","category":"page"},{"location":"abstract_types/#0-Dimensional-Element-types","page":"Abstract Types","title":"0-Dimensional Element types","text":"","category":"section"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"Different types of 0-D elements (e.g. vertices of various implementations) can be implemented by subtyping off of the abstract type","category":"page"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"ReferenceFiniteElements.AbstractVertex","category":"page"},{"location":"abstract_types/#ReferenceFiniteElements.AbstractVertex","page":"Abstract Types","title":"ReferenceFiniteElements.AbstractVertex","text":"abstract type AbstractVertex{I, P, Q} <: ReferenceFiniteElements.AbstractElementType{0, 1, 0, 0, I, P, Q}\n\n\n\n\n\n","category":"type"},{"location":"abstract_types/#1-Dimensional-Element-types","page":"Abstract Types","title":"1-Dimensional Element types","text":"","category":"section"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"Different types of 1-D elements (e.g. edges, sides, lines, etc. of various implementations) can be implemented by subtyping off of the abstract type","category":"page"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"ReferenceFiniteElements.AbstractEdge","category":"page"},{"location":"abstract_types/#ReferenceFiniteElements.AbstractEdge","page":"Abstract Types","title":"ReferenceFiniteElements.AbstractEdge","text":"abstract type AbstractEdge{V, I, P, Q} <: ReferenceFiniteElements.AbstractElementType{1, V, 1, 0, I, P, Q}\n\n\n\n\n\n","category":"type"},{"location":"abstract_types/#2-Dimensional-Element-types","page":"Abstract Types","title":"2-Dimensional Element types","text":"","category":"section"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"Different types of 2-D elements (e.g. faces, triangles, quads, polygons, etc. of various implementations) can be implemented by subtyping off of the abstract type","category":"page"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"ReferenceFiniteElements.AbstractFace","category":"page"},{"location":"abstract_types/#ReferenceFiniteElements.AbstractFace","page":"Abstract Types","title":"ReferenceFiniteElements.AbstractFace","text":"abstract type AbstractFace{V, E, I, P, Q} <: ReferenceFiniteElements.AbstractElementType{2, V, E, 1, I, P, Q}\n\n\n\n\n\n","category":"type"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"There are also various subtypes of this type including","category":"page"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"ReferenceFiniteElements.AbstractQuad\nReferenceFiniteElements.AbstractTri","category":"page"},{"location":"abstract_types/#ReferenceFiniteElements.AbstractQuad","page":"Abstract Types","title":"ReferenceFiniteElements.AbstractQuad","text":"abstract type AbstractQuad{V, I, P, Q} <: ReferenceFiniteElements.AbstractFace{V, 4, I, P, Q}\n\n\n\n\n\n","category":"type"},{"location":"abstract_types/#ReferenceFiniteElements.AbstractTri","page":"Abstract Types","title":"ReferenceFiniteElements.AbstractTri","text":"abstract type AbstractTri{V, I, P, Q} <: ReferenceFiniteElements.AbstractFace{V, 3, I, P, Q}\n\n\n\n\n\n","category":"type"},{"location":"abstract_types/#3-Dimensional-Element-types","page":"Abstract Types","title":"3-Dimensional Element types","text":"","category":"section"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"Different types of 3-D elements (e.g. volumes, hexes, tets, etc. of various implementations) can be implemented by subtyping off of the abstract type","category":"page"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"ReferenceFiniteElements.AbstractVolume","category":"page"},{"location":"abstract_types/#ReferenceFiniteElements.AbstractVolume","page":"Abstract Types","title":"ReferenceFiniteElements.AbstractVolume","text":"abstract type AbstractVolume{V, E, F, I, P, Q} <: ReferenceFiniteElements.AbstractElementType{3, V, E, F, I, P, Q}\n\n\n\n\n\n","category":"type"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"There are also various subtypes of this type including","category":"page"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"ReferenceFiniteElements.AbstractHex\nReferenceFiniteElements.AbstractTet","category":"page"},{"location":"abstract_types/#ReferenceFiniteElements.AbstractHex","page":"Abstract Types","title":"ReferenceFiniteElements.AbstractHex","text":"abstract type AbstractHex{V, I, P, Q} <: ReferenceFiniteElements.AbstractVolume{V, 12, 6, I, P, Q}\n\n\n\n\n\n","category":"type"},{"location":"abstract_types/#ReferenceFiniteElements.AbstractTet","page":"Abstract Types","title":"ReferenceFiniteElements.AbstractTet","text":"abstract type AbstractTet{V, I, P, Q} <: ReferenceFiniteElements.AbstractVolume{V, 6, 4, I, P, Q}\n\n\n\n\n\n","category":"type"},{"location":"abstract_types/#Abstract-Types-for-Storage-Containers","page":"Abstract Types","title":"Abstract Types for Storage Containers","text":"","category":"section"},{"location":"abstract_types/","page":"Abstract Types","title":"Abstract Types","text":"ReferenceFiniteElements.AbstractInterpolationType\nReferenceFiniteElements.AbstractInterpolantsContainer","category":"page"},{"location":"abstract_types/#ReferenceFiniteElements.AbstractInterpolationType","page":"Abstract Types","title":"ReferenceFiniteElements.AbstractInterpolationType","text":"abstract type AbstractInterpolationType\n\n\n\n\n\n","category":"type"},{"location":"abstract_types/#ReferenceFiniteElements.AbstractInterpolantsContainer","page":"Abstract Types","title":"ReferenceFiniteElements.AbstractInterpolantsContainer","text":"abstract type AbstractInterpolantsContainer{I}\n\n\n\n\n\n","category":"type"},{"location":"storage_types/#Storage-Types","page":"Storage Types","title":"Storage Types","text":"","category":"section"},{"location":"storage_types/","page":"Storage Types","title":"Storage Types","text":"We can setup ReferenceFE with several different backend for efficiency reasons.","category":"page"},{"location":"storage_types/","page":"Storage Types","title":"Storage Types","text":"For StaticArrays that are large than ~50 the compiler really starts to struggle, so we can fall back to traditional arrays here. The only issue there is on GPUs.  The data structures can not be transferred to GPUs for very high order elements.","category":"page"},{"location":"quick_start/#Quckstart","page":"Quick start","title":"Quckstart","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"To setup a finite element you can do the following with a 8 node hexahedral element with a first order quadrature rule (8 integration points) used as an example below","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"julia> using ReferenceFiniteElements\n\njulia> re = ReferenceFE(Hex8{Lagrange, 2}())\nReferenceFE:\n  Element Type                                  = Hex8{Lagrange, 2}\n  Surface Element Type                          = Quad4{Lagrange, 2}\n  Interpolation Type                            = Lagrange\n  Polynomial Degree                             = 1\n  Quadrature Degree                             = 2\n  Array Backend Type                            = ReferenceFiniteElements.ArrayBackend{StaticArraysCore.SArray}()\n  Edge Nodes Storage Type                       = Nothing\n  Face Nodes Storage Type                       = Matrix{Int64}\n  Interior Nodes Storage Type                   = Vector{Int64}\n  Nodal Coordinates Storage Type                = Vector{StaticArraysCore.SVector{3, Float64}}\n  CellInterpolants:\n    Quadrature Point Storage Type               = Vector{StaticArraysCore.SVector{3, Float64}}\n    Quadrature Weights Storage Type             = Vector{Float64}\n    Shape Function Values Storage Type          = Vector{StaticArraysCore.SVector{8, Float64}}\n    Shape Function Gradients Storage Type       = Vector{StaticArraysCore.SMatrix{8, 3, Float64, 24}}\n    Shape Function Hessians Storage Type        = Vector{StaticArraysCore.SArray{Tuple{8, 3, 3}, Float64, 3, 72}}\n  Surface Nodal Coordinates Storage Type        = Nothing\n  CellInterpolants:\n    Quadrature Point Storage Type               = Matrix{Vector{Float64}}\n    Quadrature Weights Storage Type             = Matrix{Float64}\n    Shape Function Values Storage Type          = Matrix{StaticArraysCore.SVector{8, Float64}}\n    Shape Function Gradients Storage Type       = Matrix{StaticArraysCore.SMatrix{8, 3, Float64, 24}}\n    Shape Function Hessians Storage Type        = Matrix{StaticArraysCore.SArray{Tuple{8, 3, 3}, Float64, 3, 72}}\n","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"To do something useful with our finite element we can look at the quadrature points. To get all the quadrature points, use the following method","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"julia> quadrature_points(re)\n8-element Vector{StaticArraysCore.SVector{3, Float64}}:\n [-0.5773502691896258, -0.5773502691896258, -0.5773502691896258]\n [0.5773502691896258, -0.5773502691896258, -0.5773502691896258]\n [-0.5773502691896258, 0.5773502691896258, -0.5773502691896258]\n [0.5773502691896258, 0.5773502691896258, -0.5773502691896258]\n [-0.5773502691896258, -0.5773502691896258, 0.5773502691896258]\n [0.5773502691896258, -0.5773502691896258, 0.5773502691896258]\n [-0.5773502691896258, 0.5773502691896258, 0.5773502691896258]\n [0.5773502691896258, 0.5773502691896258, 0.5773502691896258]\n","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"To get a specific quadrature point, say the first point, we can use an analogous method as follows","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"julia> quadrature_point(re, 1)\n3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):\n -0.5773502691896258\n -0.5773502691896258\n -0.5773502691896258\n","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"There are similar methods for the quadrature weights. See below.","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"julia> quadrature_weights(re)\n8-element Vector{Float64}:\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"julia> quadrature_weight(re, 1)\n1.0\n","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"For the shape function values we can access these via the following methods","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"julia> shape_function_values(re)\n8-element Vector{StaticArraysCore.SVector{8, Float64}}:\n [0.4905626121623441, 0.13144585576580212, 0.035220810900864506, 0.13144585576580212, 0.13144585576580212, 0.035220810900864506, 0.009437387837655926, 0.035220810900864506]\n [0.13144585576580212, 0.4905626121623441, 0.13144585576580212, 0.035220810900864506, 0.035220810900864506, 0.13144585576580212, 0.035220810900864506, 0.009437387837655926]\n [0.13144585576580212, 0.035220810900864506, 0.13144585576580212, 0.4905626121623441, 0.035220810900864506, 0.009437387837655926, 0.035220810900864506, 0.13144585576580212]\n [0.035220810900864506, 0.13144585576580212, 0.4905626121623441, 0.13144585576580212, 0.009437387837655926, 0.035220810900864506, 0.13144585576580212, 0.035220810900864506]\n [0.13144585576580212, 0.035220810900864506, 0.009437387837655926, 0.035220810900864506, 0.4905626121623441, 0.13144585576580212, 0.035220810900864506, 0.13144585576580212]\n [0.035220810900864506, 0.13144585576580212, 0.035220810900864506, 0.009437387837655926, 0.13144585576580212, 0.4905626121623441, 0.13144585576580212, 0.035220810900864506]\n [0.035220810900864506, 0.009437387837655926, 0.035220810900864506, 0.13144585576580212, 0.13144585576580212, 0.035220810900864506, 0.13144585576580212, 0.4905626121623441]\n [0.009437387837655926, 0.035220810900864506, 0.13144585576580212, 0.035220810900864506, 0.035220810900864506, 0.13144585576580212, 0.4905626121623441, 0.13144585576580212]\n","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"julia> shape_function_value(re, 1)\n8-element StaticArraysCore.SVector{8, Float64} with indices SOneTo(8):\n 0.4905626121623441\n 0.13144585576580212\n 0.035220810900864506\n 0.13144585576580212\n 0.13144585576580212\n 0.035220810900864506\n 0.009437387837655926\n 0.035220810900864506\n","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"For shape function gradients, one can use the methods shape_function_gradients  or shape_function_gradient respectively. This example is ommitted for brevity.","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"For shape function hessians, one can use the methods shape_function_hessians  or shape_function_hessian respectively. This example is ommitted for brevity.","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"CurrentModule = ReferenceFiniteElements","category":"page"},{"location":"developer/#How-to-add-a-new-element-type","page":"Developer","title":"How to add a new element type","text":"","category":"section"},{"location":"developer/","page":"Developer","title":"Developer","text":"To add a new finite element there's a few things we need to do. First, we may need to define an abstract type if the element type is not a currently supported abstract element topology. The currently supported abstract element topologies are   ","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"AbstractEdge\nAbstractFace\nAbstractQuad\nAbstractTri\nAbstractVolume\nAbstractHex\nAbstractTet","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"We'll use a MyTri3 element as an example of how to add a new element type.","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"First, let's pretend AbstractTri doesn't exist yet. The first thing we need to do is define the following abstract type","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"julia> using ReferenceFiniteElements\n\njulia> abstract type AbstractTri{V, I, P, Q} <: ReferenceFiniteElements.AbstractFace{V, 3, I, P, Q} end\n","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"The four parameters V, I, P, and Q are the number of vertices, interpolation type, the polynomial degree, and the number of quadrature degree for an element implementation. For a given element topology, such as a three noded triangle in this example, V will be fixed parameters while we allow for I, P, and Q to be variable, i.e. have potentially different interpolation and quadrature rules on a triangular element. The number 3 above corresponds to the number of edges in the face topology. ","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"We now need to define some methods for basics about the element toplogy such as number of vertices, edges, faces, etc.","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"TODO finish this part of the documention! TODO change nodal_coordinates and surface_nodal_coordinates to be vertex_coordinates and surface_vertex_coordinates respectively. TODO also surface_nodal_coordinates is likely redundant.","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"The complete list of methods that need to be defined for a new abstract topology type include the following:","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"element_edge_nodes\nelement_face_nodes\nelement_interior_nodes\nnodal_coordinates\nnum_edges\nnum_faces\nnum_interior_vertices\nnum_quadrature_points\nnum_vertices\nnum_vertices_per_edge\nnum_vertices_per_face\nquadrature_points_and_weights\nsurface_element\nsurface_element_type\nsurface_nodal_coordinates\nsurface_quadrature_points_and_weights","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"Now we define a struct for specific implementations. Here we'll define the MyTri3 struct.","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"julia> struct MyTri3{I, Q} <: AbstractTri{3, I, 1, Q} end\n\njulia> ReferenceFiniteElements.surface_element(e::MyTri3{Lagrange, Q}) where Q = Edge2{Lagrange, Q}()\n\njulia> e = MyTri3{Lagrange, 1}()\nMyTri3{Lagrange, 1}()\n\njulia> ReferenceFiniteElements.num_edges(e)\n3","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"Here we have fixed P to be 1 respectively while I and Q are left as parametric types to correspond to a linear interpolation but with a generic interpolation and quadrature rule.","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"Now that we have a basic type to represent our element topology defined, we now need to  implement our interpolation scheme. The methods needed for specific interpolation types include the following:","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"shape_function_values\nshape_funciton_gradients\nshape_function_hessians","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"Below is an example for the MyTri3 element above","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"function shape_function_value(e::MyTri3{Lagrange}, X, ξ, backend::ReferenceFiniteElements.ArrayBackend)\n  Ns = convert_to_vector(e, backend,\n    1. - ξ[1] - ξ[2],\n    ξ[1],\n    ξ[2]\n  )\n  return Ns\nend\n\n# output\nshape_function_value (generic function with 1 method)\n","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"function shape_function_gradient(e::MyTri3{Lagrange}, X, ξ, backend::ReferenceFiniteElements.ArrayBackend)\n  Ns = convert_to_matrix(e, backend,\n    -1., \n    1., \n    0.,\n    #\n    -1., \n    0., \n    1.\n  )\n  return Ns\nend\n\n# output\nshape_function_gradient (generic function with 1 method)\n","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"function shape_function_hessian(e::MyTri3{Lagrange}, X, ξ, backend::ReferenceFiniteElements.ArrayBackend)\n  Ns = convert_to_3d_array(e, backend,\n    0., 0.,\n    0., 0.,\n    0., 0.,\n    #\n    0., 0.,\n    0., 0.,\n    0., 0.\n  )\n  return Ns\nend\n\n# output\nshape_function_hessian (generic function with 1 method)\n","category":"page"},{"location":"element_types/#Element-types","page":"Element Types","title":"Element types","text":"","category":"section"},{"location":"element_types/","page":"Element Types","title":"Element Types","text":"Below is the currently implemented set of elements organized by vertices, edges, faces, and volumes respectively. If you would like to see an additional element type supported, please file and issue or open a PR.","category":"page"},{"location":"element_types/#0-Dimensional-Elements","page":"Element Types","title":"0-Dimensional Elements","text":"","category":"section"},{"location":"element_types/","page":"Element Types","title":"Element Types","text":"Vertex","category":"page"},{"location":"element_types/#ReferenceFiniteElements.Vertex","page":"Element Types","title":"ReferenceFiniteElements.Vertex","text":"struct Vertex{I, P, Q} <: ReferenceFiniteElements.AbstractVertex{I, P, Q}\n\n\n\n\n\n","category":"type"},{"location":"element_types/#1-Dimensional-Elements","page":"Element Types","title":"1-Dimensional Elements","text":"","category":"section"},{"location":"element_types/","page":"Element Types","title":"Element Types","text":"Edge\nEdge0\nEdge2\nEdge3","category":"page"},{"location":"element_types/#ReferenceFiniteElements.Edge","page":"Element Types","title":"ReferenceFiniteElements.Edge","text":"struct Edge{V, I, P, Q} <: ReferenceFiniteElements.AbstractEdge{V, I, P, Q}\n\n\n\n\n\n","category":"type"},{"location":"element_types/#ReferenceFiniteElements.Edge0","page":"Element Types","title":"ReferenceFiniteElements.Edge0","text":"struct Edge0{I, Q} <: ReferenceFiniteElements.AbstractEdge{2, I, 0, Q}\n\n\n\n\n\n","category":"type"},{"location":"element_types/#ReferenceFiniteElements.Edge2","page":"Element Types","title":"ReferenceFiniteElements.Edge2","text":"struct Edge2{I, Q} <: ReferenceFiniteElements.AbstractEdge{2, I, 1, Q}\n\n\n\n\n\n","category":"type"},{"location":"element_types/#ReferenceFiniteElements.Edge3","page":"Element Types","title":"ReferenceFiniteElements.Edge3","text":"struct Edge3{I, Q} <: ReferenceFiniteElements.AbstractEdge{3, I, 2, Q}\n\n\n\n\n\n","category":"type"},{"location":"element_types/#2-Dimensional-Elements","page":"Element Types","title":"2-Dimensional Elements","text":"","category":"section"},{"location":"element_types/","page":"Element Types","title":"Element Types","text":"Quad\nQuad0\nQuad4\nQuad9\nTri\nTri0\nTri3\nTri6","category":"page"},{"location":"element_types/#ReferenceFiniteElements.Quad","page":"Element Types","title":"ReferenceFiniteElements.Quad","text":"struct Quad{V, I, P, Q} <: ReferenceFiniteElements.AbstractQuad{V, I, P, Q}\n\n\n\n\n\n","category":"type"},{"location":"element_types/#ReferenceFiniteElements.Quad0","page":"Element Types","title":"ReferenceFiniteElements.Quad0","text":"struct Quad0{I, Q} <: ReferenceFiniteElements.AbstractQuad{4, I, 0, Q}\n\n\n\n\n\n","category":"type"},{"location":"element_types/#ReferenceFiniteElements.Quad4","page":"Element Types","title":"ReferenceFiniteElements.Quad4","text":"struct Quad4{I, Q} <: ReferenceFiniteElements.AbstractQuad{4, I, 1, Q}\n\n\n\n\n\n","category":"type"},{"location":"element_types/#ReferenceFiniteElements.Quad9","page":"Element Types","title":"ReferenceFiniteElements.Quad9","text":"struct Quad9{I, Q} <: ReferenceFiniteElements.AbstractQuad{9, I, 2, Q}\n\n\n\n\n\n","category":"type"},{"location":"element_types/#ReferenceFiniteElements.Tri","page":"Element Types","title":"ReferenceFiniteElements.Tri","text":"struct Tri{V, I, P, Q} <: ReferenceFiniteElements.AbstractTri{V, I, P, Q}\n\n\n\n\n\n","category":"type"},{"location":"element_types/#ReferenceFiniteElements.Tri0","page":"Element Types","title":"ReferenceFiniteElements.Tri0","text":"struct Tri0{I, Q} <: ReferenceFiniteElements.AbstractTri{3, I, 0, Q}\n\n\n\n\n\n","category":"type"},{"location":"element_types/#ReferenceFiniteElements.Tri3","page":"Element Types","title":"ReferenceFiniteElements.Tri3","text":"struct Tri3{I, Q} <: ReferenceFiniteElements.AbstractTri{3, I, 1, Q}\n\n\n\n\n\n","category":"type"},{"location":"element_types/#ReferenceFiniteElements.Tri6","page":"Element Types","title":"ReferenceFiniteElements.Tri6","text":"struct Tri6{I, Q} <: ReferenceFiniteElements.AbstractTri{6, I, 2, Q}\n\n\n\n\n\n","category":"type"},{"location":"element_types/#3-Dimensional-Elements","page":"Element Types","title":"3-Dimensional Elements","text":"","category":"section"},{"location":"element_types/","page":"Element Types","title":"Element Types","text":"Hex0\nHex8\nTet0\nTet4\nTet10","category":"page"},{"location":"element_types/#ReferenceFiniteElements.Hex0","page":"Element Types","title":"ReferenceFiniteElements.Hex0","text":"struct Hex0{I, Q} <: ReferenceFiniteElements.AbstractHex{8, I, 0, Q}\n\n\n\n\n\n","category":"type"},{"location":"element_types/#ReferenceFiniteElements.Hex8","page":"Element Types","title":"ReferenceFiniteElements.Hex8","text":"struct Hex8{I, Q} <: ReferenceFiniteElements.AbstractHex{8, I, 1, Q}\n\n\n\n\n\n","category":"type"},{"location":"element_types/#ReferenceFiniteElements.Tet0","page":"Element Types","title":"ReferenceFiniteElements.Tet0","text":"struct Tet0{I, Q} <: ReferenceFiniteElements.AbstractTet{4, I, 0, Q}\n\n\n\n\n\n","category":"type"},{"location":"element_types/#ReferenceFiniteElements.Tet4","page":"Element Types","title":"ReferenceFiniteElements.Tet4","text":"struct Tet4{I, Q} <: ReferenceFiniteElements.AbstractTet{4, I, 1, Q}\n\n\n\n\n\n","category":"type"},{"location":"element_types/#ReferenceFiniteElements.Tet10","page":"Element Types","title":"ReferenceFiniteElements.Tet10","text":"struct Tet10{I, Q} <: ReferenceFiniteElements.AbstractTet{10, I, 2, Q}\n\n\n\n\n\n","category":"type"},{"location":"installation/","page":"Installation","title":"Installation","text":"CurrentModule = ReferenceFiniteElements","category":"page"},{"location":"installation/#ReferenceFiniteElements","page":"Installation","title":"ReferenceFiniteElements","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Documentation for ReferenceFiniteElements.","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To use ReferenceFiniteElements first install it via the package manager via the following command","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"pkg> add ReferenceFiniteElements","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"or ","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(\"ReferenceFiniteElements\")","category":"page"},{"location":"","page":"Index","title":"Index","text":"CurrentModule = ReferenceFiniteElements","category":"page"},{"location":"","page":"Index","title":"Index","text":"","category":"page"},{"location":"","page":"Index","title":"Index","text":"<!– @autodocs Modules = [ReferenceFiniteElements] –>","category":"page"},{"location":"extensions/#ReferenceFiniteElementsAdaptExt","page":"ReferenceFiniteElementsAdaptExt","title":"ReferenceFiniteElementsAdaptExt","text":"","category":"section"},{"location":"extensions/","page":"ReferenceFiniteElementsAdaptExt","title":"ReferenceFiniteElementsAdaptExt","text":"For using ReferenceFiniteElements on GPUs. So far only tested with CUDA.jl as the GPU backend.","category":"page"},{"location":"extensions/#ReferenceFiniteElementsExodusExt","page":"ReferenceFiniteElementsAdaptExt","title":"ReferenceFiniteElementsExodusExt","text":"","category":"section"},{"location":"extensions/","page":"ReferenceFiniteElementsAdaptExt","title":"ReferenceFiniteElementsAdaptExt","text":"Convenience methods for setting up ReferenceFEs based on an Exodus block. Really only useful if you use exodusII mesh types.","category":"page"},{"location":"extensions/#ReferenceFiniteElementsRecipesBaseExt","page":"ReferenceFiniteElementsAdaptExt","title":"ReferenceFiniteElementsRecipesBaseExt","text":"","category":"section"},{"location":"extensions/","page":"ReferenceFiniteElementsAdaptExt","title":"ReferenceFiniteElementsAdaptExt","text":"Plotting tools for educational purposes. To use, try the following","category":"page"},{"location":"extensions/","page":"ReferenceFiniteElementsAdaptExt","title":"ReferenceFiniteElementsAdaptExt","text":"using ReferenceFiniteElements, Plots, LaTeXStrings\nre = ReferenceFE(Tri6(2))\nplot(re) # plots nodes and edges of element along with quadrature points\nplot(re, 1) # plots shape function values. The index is the shape function index\nplot(re, 1, 1) # plots shape function gradients. The first index is for the index, second is for dimension\nplot(re, 1, 1, 1) # plots shape function hessians. The first index  is for the shape function index and the second and third are for dimensions","category":"page"}]
}
